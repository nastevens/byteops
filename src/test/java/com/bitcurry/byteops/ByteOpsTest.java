// This is free and unencumbered software released into the public domain.
// 
// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any
// means.
// 
// In jurisdictions that recognize copyright laws, the author or authors
// of this software dedicate any and all copyright interest in the
// software to the public domain. We make this dedication for the benefit
// of the public at large and to the detriment of our heirs and
// successors. We intend this dedication to be an overt act of
// relinquishment in perpetuity of all present and future rights to this
// software under copyright law.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
// 
// For more information, please refer to <http://unlicense.org/>

package com.bitcurry.byteops;

import static org.junit.Assert.assertEquals;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Scanner;

import org.junit.Test;

/*
 * Notes
 * 
 * Because I don't trust my ability to properly implement the ByteOps methods
 * correctly in Java, all the test sets are created by a utility C program. The
 * test sets are then loaded in JUnit as Integers, which will treat 0x00 as "0"
 * and 0xFF as "255". I hold on to the Integer type until the very last moment
 * before actually calling the ByteOps method, at which time I call either
 * intValue() or byteValue().  This seems to do the Right Thing.
 */
public class ByteOpsTest {
	
	private Integer[][] testSet = null;
	
	// load a test set generated by gen_test_sets.c
	private void loadTestSet(String resource, int op1UpperLimit, int op2UpperLimit) throws IOException {
		InputStream is = getClass().getResourceAsStream(resource);
		BufferedReader in = new BufferedReader(new InputStreamReader(is));
		testSet = new Integer[op1UpperLimit][op2UpperLimit];
		
		String line = null;
		int op1=0, op2=0;
		line = in.readLine();
		while (line != null) {
			op2 = 0;
			Scanner scanner = new Scanner(line);
			scanner.useDelimiter(" ");
			while (scanner.hasNext()) {
				testSet[op1][op2] = Integer.valueOf(scanner.next(), 16);
				op2++;
			}
			scanner.close();
			op1++;
			line = in.readLine();
		}
		in.close();
	}
	
	@Test
	public void testAnd() throws IOException {
		loadTestSet("/and_testset.txt", 256, 256);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 256; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.and(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.and(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.and(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.and(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testOr() throws IOException {
		loadTestSet("/or_testset.txt", 256, 256);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 256; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.or(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.or(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.or(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.or(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testXor() throws IOException {
		loadTestSet("/xor_testset.txt", 256, 256);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 256; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.xor(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.xor(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.xor(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.xor(op1.intValue(), op2.intValue()));
			}
		}
	}
	
	@Test
	public void testNot() throws IOException {
		loadTestSet("/not_testset.txt", 256, 1);
		for (int i = 0; i < 256; i++) {
			Integer op1 = Integer.valueOf(i);
			byte expected = testSet[i][0].byteValue();
			assertEquals(expected, ByteOps.not(op1.byteValue()));
			assertEquals(expected, ByteOps.not(op1.intValue()));
		}
	}
	
	@Test
	public void testLrotate() throws IOException {
		loadTestSet("/lrotate_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.lrotate(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lrotate(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.lrotate(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lrotate(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testLshift() throws IOException {
		loadTestSet("/lshift_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.lshift(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lshift(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.lshift(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lshift(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testRrotate() throws IOException {
		loadTestSet("/rrotate_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.rrotate(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rrotate(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.rrotate(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rrotate(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testRshift() throws IOException {
		loadTestSet("/rshift_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.rshift(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rshift(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.rshift(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rshift(op1.intValue(), op2.intValue()));
			}
		}
	}

}
