package com.bitcurry.byteops;

import static org.junit.Assert.assertEquals;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Scanner;

import org.junit.Test;

/*
 * Notes - or why Java byte operations suck
 * 
 * When trying to come up with unit tests for this library I quickly ran into
 * the issue of simply "recreating" the main code in a separate file rather
 * than developing an actual test. The problem is that there is no sane way
 * to represent raw unsigned bytes in Java. If you need more proof of this
 * try to run the code 'Byte.valueOf("FF", 16)'. Because everything in Java
 * is signed, the code above results in a NumberException, as the max value
 * for a byte is 127.
 * 
 * The problem with having everything signed becomes more obvious when trying
 * to work with hex data, which is almost always treated as unsigned. There 
 * are workarounds scattered throughout the Java API, most of them involving
 * using an int to represent a value from 0 to 255. This works fine until
 * you start using any of the byte-oriented stream interfaces or need to do
 * real bitwise operations on individual bytes.
 * 
 * Back to these unit tests. Because I don't trust my ability to properly
 * implement the ByteOps methods correctly in Java, all the test sets are 
 * created by a utility C program. The test sets are then loaded in JUnit
 * as Integers, which will treat 0x00 as "0" and 0xFF as "255". I hold on
 * to the Integer type until the very last moment before actually calling
 * the ByteOps method, at which time I call either intValue() or byteValue().
 * This seems to do the Right Thing.
 * 
 * Seriously, I love you Java, but you desperately need to get your act
 * together on dealing with bytes.
 */
public class ByteOpsTest {
	
	private Integer[][] testSet = null;
	
	// load a test set generated by gen_test_sets.c
	private void loadTestSet(String resource, int op1UpperLimit, int op2UpperLimit) throws IOException {
		InputStream is = getClass().getResourceAsStream(resource);
		BufferedReader in = new BufferedReader(new InputStreamReader(is));
		testSet = new Integer[op1UpperLimit][op2UpperLimit];
		
		String line = null;
		int op1=0, op2=0;
		line = in.readLine();
		while (line != null) {
			op2 = 0;
			Scanner scanner = new Scanner(line);
			scanner.useDelimiter(" ");
			while (scanner.hasNext()) {
				testSet[op1][op2] = Integer.valueOf(scanner.next(), 16);
				op2++;
			}
			scanner.close();
			op1++;
			line = in.readLine();
		}
		in.close();
	}
	
	@Test
	public void testAnd() throws IOException {
		loadTestSet("/and_testset.txt", 256, 256);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 256; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.and(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.and(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.and(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.and(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testOr() throws IOException {
		loadTestSet("/or_testset.txt", 256, 256);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 256; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.or(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.or(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.or(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.or(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testXor() throws IOException {
		loadTestSet("/xor_testset.txt", 256, 256);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 256; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.xor(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.xor(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.xor(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.xor(op1.intValue(), op2.intValue()));
			}
		}
	}
	
	@Test
	public void testNot() throws IOException {
		loadTestSet("/not_testset.txt", 256, 1);
		for (int i = 0; i < 256; i++) {
			Integer op1 = Integer.valueOf(i);
			byte expected = testSet[i][0].byteValue();
			assertEquals(expected, ByteOps.not(op1.byteValue()));
			assertEquals(expected, ByteOps.not(op1.intValue()));
		}
	}
	
	@Test
	public void testLrotate() throws IOException {
		loadTestSet("/lrotate_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.lrotate(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lrotate(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.lrotate(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lrotate(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testLshift() throws IOException {
		loadTestSet("/lshift_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.lshift(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lshift(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.lshift(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.lshift(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testRrotate() throws IOException {
		loadTestSet("/rrotate_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.rrotate(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rrotate(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.rrotate(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rrotate(op1.intValue(), op2.intValue()));
			}
		}
	}

	@Test
	public void testRshift() throws IOException {
		loadTestSet("/rshift_testset.txt", 256, 8);
		for (int i = 0; i < 256; i++) {
			for (int j = 0; j < 8; j++) {
				Integer op1 = Integer.valueOf(i);
				Integer op2 = Integer.valueOf(j);
				byte expected = testSet[i][j].byteValue();
				assertEquals(expected, ByteOps.rshift(op1.byteValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rshift(op1.byteValue(), op2.intValue()));
				assertEquals(expected, ByteOps.rshift(op1.intValue(), op2.byteValue()));
				assertEquals(expected, ByteOps.rshift(op1.intValue(), op2.intValue()));
			}
		}
	}

}
